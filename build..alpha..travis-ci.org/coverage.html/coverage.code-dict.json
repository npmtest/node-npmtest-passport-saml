{"/home/travis/build/npmtest/node-npmtest-passport-saml/test.js":"/* istanbul instrument in package npmtest_passport_saml */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-passport-saml/lib.npmtest_passport_saml.js":"/* istanbul instrument in package npmtest_passport_saml */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_passport_saml = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_passport_saml = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-passport-saml/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-passport-saml && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_passport_saml */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_passport_saml\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_passport_saml.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_passport_saml.rollup.js'] =\n            local.assetsDict['/assets.npmtest_passport_saml.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_passport_saml.__dirname + '/lib.npmtest_passport_saml.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-passport-saml/node_modules/passport-saml/lib/passport-saml/index.js":"exports.Strategy = require('./strategy');\nexports.SAML = require('./saml').SAML;\n","/home/travis/build/npmtest/node-npmtest-passport-saml/node_modules/passport-saml/lib/passport-saml/strategy.js":"var passport = require('passport-strategy');\nvar util = require('util');\nvar saml = require('./saml');\n\nfunction Strategy (options, verify) {\n  if (typeof options == 'function') {\n    verify = options;\n    options = {};\n  }\n\n  if (!verify) {\n    throw new Error('SAML authentication strategy requires a verify function');\n  }\n\n  this.name = 'saml';\n\n  passport.Strategy.call(this);\n\n  this._verify = verify;\n  this._saml = new saml.SAML(options);\n  this._passReqToCallback = !!options.passReqToCallback;\n  this._authnRequestBinding = options.authnRequestBinding || 'HTTP-Redirect';\n}\n\nutil.inherits(Strategy, passport.Strategy);\n\nStrategy.prototype.authenticate = function (req, options) {\n  var self = this;\n\n  options.samlFallback = options.samlFallback || 'login-request';\n\n  function validateCallback(err, profile, loggedOut) {\n      if (err) {\n        return self.error(err);\n      }\n\n      if (loggedOut) {\n        req.logout();\n        if (profile) {\n          req.samlLogoutRequest = profile;\n          return self._saml.getLogoutResponseUrl(req, redirectIfSuccess);\n        }\n        return self.pass();\n      }\n\n      var verified = function (err, user, info) {\n        if (err) {\n          return self.error(err);\n        }\n\n        if (!user) {\n          return self.fail(info);\n        }\n\n        self.success(user, info);\n      };\n\n      if (self._passReqToCallback) {\n        self._verify(req, profile, verified);\n      } else {\n        self._verify(profile, verified);\n      }\n  }\n\n  function redirectIfSuccess(err, url) {\n    if (err) {\n      self.error(err);\n    } else {\n      self.redirect(url);\n    }\n  }\n\n  if (req.body && req.body.SAMLResponse) {\n      this._saml.validatePostResponse(req.body, validateCallback);\n  } else if (req.body && req.body.SAMLRequest) {\n      this._saml.validatePostRequest(req.body, validateCallback);\n  } else {\n    var requestHandler = {\n      'login-request': function() {\n        if (self._authnRequestBinding === 'HTTP-POST') {\n          this._saml.getAuthorizeForm(req, function(err, data) {\n            if (err) {\n              self.error(err);\n            } else {\n              var res = req.res;\n              res.send(data);\n            }\n          });\n        } else { // Defaults to HTTP-Redirect\n          this._saml.getAuthorizeUrl(req, redirectIfSuccess);\n        }\n      }.bind(self),\n      'logout-request': function() {\n          this._saml.getLogoutUrl(req, redirectIfSuccess);\n      }.bind(self)\n    }[options.samlFallback];\n\n    if (typeof requestHandler !== 'function') {\n      return self.fail();\n    }\n\n    requestHandler();\n  }\n};\n\nStrategy.prototype.logout = function(req, callback) {\n  this._saml.getLogoutUrl(req, callback);\n};\n\nStrategy.prototype.generateServiceProviderMetadata = function( decryptionCert ) {\n  return this._saml.generateServiceProviderMetadata( decryptionCert );\n};\n\nmodule.exports = Strategy;\n","/home/travis/build/npmtest/node-npmtest-passport-saml/node_modules/passport-saml/lib/passport-saml/saml.js":"var zlib = require('zlib');\nvar xml2js = require('xml2js');\nvar xmlCrypto = require('xml-crypto');\nvar crypto = require('crypto');\nvar xmldom = require('xmldom');\nvar url = require('url');\nvar querystring = require('querystring');\nvar xmlbuilder = require('xmlbuilder');\nvar xmlenc = require('xml-encryption');\nvar xpath = xmlCrypto.xpath;\nvar InMemoryCacheProvider = require('./inmemory-cache-provider.js').CacheProvider;\nvar Q = require('q');\n\nvar SAML = function (options) {\n  var self = this;\n\n  this.options = this.initialize(options);\n  this.cacheProvider = this.options.cacheProvider;\n};\n\nSAML.prototype.initialize = function (options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (!options.path) {\n    options.path = '/saml/consume';\n  }\n\n  if (!options.host) {\n    options.host = 'localhost';\n  }\n\n  if (!options.issuer) {\n    options.issuer = 'onelogin_saml';\n  }\n\n  if (options.identifierFormat === undefined) {\n    options.identifierFormat = \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\";\n  }\n\n  if (options.authnContext === undefined) {\n    options.authnContext = \"urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport\";\n  }\n\n  if (!options.acceptedClockSkewMs) {\n    // default to no skew\n    options.acceptedClockSkewMs = 0;\n  }\n\n  if(!options.validateInResponseTo){\n    options.validateInResponseTo = false;\n  }\n\n  if(!options.requestIdExpirationPeriodMs){\n    options.requestIdExpirationPeriodMs = 28800000;  // 8 hours\n  }\n\n  if(!options.cacheProvider){\n      options.cacheProvider = new InMemoryCacheProvider(\n          {keyExpirationPeriodMs: options.requestIdExpirationPeriodMs });\n  }\n  \n  if (!options.logoutUrl) {\n    // Default to Entry Point\n    options.logoutUrl = options.entryPoint || '';\n  }\n\n  // sha1 or sha256\n  if (!options.signatureAlgorithm) {\n    options.signatureAlgorithm = 'sha1';\n  }\n\n  return options;\n};\n\nSAML.prototype.getProtocol = function (req) {\n  return this.options.protocol || (req.protocol || 'http').concat('://');\n};\n\nSAML.prototype.getCallbackUrl = function (req) {\n    // Post-auth destination\n  if (this.options.callbackUrl) {\n    return this.options.callbackUrl;\n  } else {\n    var host;\n    if (req.headers) {\n      host = req.headers.host;\n    } else {\n      host = this.options.host;\n    }\n    return this.getProtocol(req) + host + this.options.path;\n  }\n};\n\nSAML.prototype.generateUniqueID = function () {\n  var chars = \"abcdef0123456789\";\n  var uniqueID = \"\";\n  for (var i = 0; i < 20; i++) {\n    uniqueID += chars.substr(Math.floor((Math.random()*15)), 1);\n  }\n  return uniqueID;\n};\n\nSAML.prototype.generateInstant = function () {\n  return new Date().toISOString();\n};\n\nSAML.prototype.signRequest = function (samlMessage) {\n  var signer;\n  var samlMessageToSign = {};\n  switch(this.options.signatureAlgorithm) {\n    case 'sha256':\n      samlMessage.SigAlg = 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256';\n      signer = crypto.createSign('RSA-SHA256');\n      break;\n    default:\n      samlMessage.SigAlg = 'http://www.w3.org/2000/09/xmldsig#rsa-sha1';\n      signer = crypto.createSign('RSA-SHA1');\n      break;\n  }\n  if (samlMessage.SAMLRequest) {\n    samlMessageToSign.SAMLRequest = samlMessage.SAMLRequest;\n  }\n  if (samlMessage.SAMLResponse) {\n    samlMessageToSign.SAMLResponse = samlMessage.SAMLResponse;\n  }\n  if (samlMessage.RelayState) {\n    samlMessageToSign.RelayState = samlMessage.RelayState;\n  }\n  if (samlMessage.SigAlg) {\n    samlMessageToSign.SigAlg = samlMessage.SigAlg;\n  }\n  signer.update(querystring.stringify(samlMessageToSign));\n  samlMessage.Signature = signer.sign(this.options.privateCert, 'base64');\n};\n\nSAML.prototype.generateAuthorizeRequest = function (req, isPassive, callback) {\n  var self = this;\n  var id = \"_\" + self.generateUniqueID();\n  var instant = self.generateInstant();\n  var forceAuthn = self.options.forceAuthn || false;\n\n  Q.fcall(function() {\n    if(self.options.validateInResponseTo) {\n      return Q.ninvoke(self.cacheProvider, 'save', id, instant);\n    } else {\n      return Q();\n    }\n  })\n  .then(function(){\n    var request = {\n      'samlp:AuthnRequest': {\n        '@xmlns:samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',\n        '@ID': id,\n        '@Version': '2.0',\n        '@IssueInstant': instant,\n        '@ProtocolBinding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST',\n        '@AssertionConsumerServiceURL': self.getCallbackUrl(req),\n        '@Destination': self.options.entryPoint,        \n        'saml:Issuer' : {\n          '@xmlns:saml' : 'urn:oasis:names:tc:SAML:2.0:assertion',\n          '#text': self.options.issuer\n        }\n      }\n    };\n\n    if (isPassive)\n      request['samlp:AuthnRequest']['@IsPassive'] = true;\n\n    if (forceAuthn) {\n      request['samlp:AuthnRequest']['@ForceAuthn'] = true;\n    }\n\n    if (self.options.identifierFormat) {\n      request['samlp:AuthnRequest']['samlp:NameIDPolicy'] = {\n        '@xmlns:samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',\n        '@Format': self.options.identifierFormat,\n        '@AllowCreate': 'true'\n      };\n    }\n\n    if (!self.options.disableRequestedAuthnContext) {\n      request['samlp:AuthnRequest']['samlp:RequestedAuthnContext'] = {\n        '@xmlns:samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',\n        '@Comparison': 'exact',\n        'saml:AuthnContextClassRef': {\n          '@xmlns:saml': 'urn:oasis:names:tc:SAML:2.0:assertion',\n          '#text': self.options.authnContext\n        }\n      };\n    }\n\n    if (self.options.attributeConsumingServiceIndex) {\n      request['samlp:AuthnRequest']['@AttributeConsumingServiceIndex'] = self.options.attributeConsumingServiceIndex;\n    }\n\n    callback(null, xmlbuilder.create(request).end());\n  })\n  .fail(function(err){\n    callback(err);\n  })\n  .done();\n};\n\nSAML.prototype.generateLogoutRequest = function (req) {\n  var id = \"_\" + this.generateUniqueID();\n  var instant = this.generateInstant();\n\n  var request = {\n    'samlp:LogoutRequest' : {\n      '@xmlns:samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',\n      '@xmlns:saml': 'urn:oasis:names:tc:SAML:2.0:assertion',\n      '@ID': id,\n      '@Version': '2.0',\n      '@IssueInstant': instant,\n      '@Destination': this.options.logoutUrl,\n      'saml:Issuer' : {\n        '@xmlns:saml': 'urn:oasis:names:tc:SAML:2.0:assertion',\n        '#text': this.options.issuer\n      },\n      'saml:NameID' : {\n        '@Format': req.user.nameIDFormat,\n        '#text': req.user.nameID\n      }\n    }\n  };\n\n  if (typeof(req.user.nameQualifier) !== 'undefined') {\n    request['samlp:LogoutRequest']['saml:NameID']['@NameQualifier'] = req.user.nameQualifier;\n  }\n\n  if (typeof(req.user.spNameQualifier) !== 'undefined') {\n    request['samlp:LogoutRequest']['saml:NameID']['@SPNameQualifier'] = req.user.spNameQualifier;\n  }\n\n  if (req.user.sessionIndex) {\n    request['samlp:LogoutRequest']['saml2p:SessionIndex'] = {\n      '@xmlns:saml2p': 'urn:oasis:names:tc:SAML:2.0:protocol',\n      '#text': req.user.sessionIndex\n    };\n  }\n\n  return xmlbuilder.create(request).end();\n};\n\nSAML.prototype.generateLogoutResponse = function (req, logoutRequest) {\n  var id = \"_\" + this.generateUniqueID();\n  var instant = this.generateInstant();\n\n  var request = {\n    'samlp:LogoutResponse' : {\n      '@xmlns:samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',\n      '@xmlns:saml': 'urn:oasis:names:tc:SAML:2.0:assertion',\n      '@ID': id,\n      '@Version': '2.0',\n      '@IssueInstant': instant,\n      '@Destination': this.options.logoutUrl,\n      '@InResponseTo': logoutRequest.ID,\n      'saml:Issuer' : {\n        '#text': this.options.issuer\n      },\n      'samlp:Status': {\n        'samlp:StatusCode': {\n          '@Value': 'urn:oasis:names:tc:SAML:2.0:status:Success'\n        }\n      }\n    }\n  };\n\n  return xmlbuilder.create(request).end();\n};\n\nSAML.prototype.requestToUrl = function (request, response, operation, additionalParameters, callback) {\n  var self = this;\n  if (self.options.skipRequestCompression)\n    requestToUrlHelper(null, new Buffer(request || response, 'utf8'));\n  else\n    zlib.deflateRaw(request || response, requestToUrlHelper);\n\n  function requestToUrlHelper(err, buffer) {\n    if (err) {\n      return callback(err);\n    }\n\n    var base64 = buffer.toString('base64');\n    var target = url.parse(self.options.entryPoint, true);\n\n    if (operation === 'logout') {\n      if (self.options.logoutUrl) {\n        target = url.parse(self.options.logoutUrl, true);\n      }\n    } else if (operation !== 'authorize') {\n        return callback(new Error(\"Unknown operation: \"+operation));\n    }\n\n    var samlMessage = request ? {\n      SAMLRequest: base64\n    } : {\n      SAMLResponse: base64\n    };\n    Object.keys(additionalParameters).forEach(function(k) {\n      samlMessage[k] = additionalParameters[k];\n    });\n\n    if (self.options.privateCert) {\n      // sets .SigAlg and .Signature\n      self.signRequest(samlMessage);\n    }\n    Object.keys(samlMessage).forEach(function(k) {\n      target.query[k] = samlMessage[k];\n    });\n\n    // Delete 'search' to for pulling query string from 'query'\n    // https://nodejs.org/api/url.html#url_url_format_urlobj\n    delete target.search;\n\n    callback(null, url.format(target));\n  }\n};\n\nSAML.prototype.getAdditionalParams = function (req, operation) {\n  var additionalParams = {};\n\n  var RelayState = req.query && req.query.RelayState || req.body && req.body.RelayState;\n  if (RelayState) {\n    additionalParams.RelayState = RelayState;\n  }\n\n  var optionsAdditionalParams = this.options.additionalParams || {};\n  Object.keys(optionsAdditionalParams).forEach(function(k) {\n    additionalParams[k] = optionsAdditionalParams[k];\n  });\n\n  var optionsAdditionalParamsForThisOperation = {};\n  if (operation == \"authorize\") {\n    optionsAdditionalParamsForThisOperation = this.options.additionalAuthorizeParams || {};\n  }\n  if (operation == \"logout\") {\n    optionsAdditionalParamsForThisOperation = this.options.additionalLogoutParams || {};\n  }\n\n  Object.keys(optionsAdditionalParamsForThisOperation).forEach(function(k) {\n    additionalParams[k] = optionsAdditionalParamsForThisOperation[k];\n  });\n\n  return additionalParams;\n};\n\nSAML.prototype.getAuthorizeUrl = function (req, callback) {\n  var self = this;\n  self.generateAuthorizeRequest(req, self.options.passive, function(err, request){\n    if (err)\n      return callback(err);\n    var operation = 'authorize';\n    self.requestToUrl(request, null, operation, self.getAdditionalParams(req, operation), callback);\n  });\n};\n\nSAML.prototype.getAuthorizeForm = function (req, callback) {\n  var self = this;\n\n  // The quoteattr() function is used in a context, where the result will not be evaluated by javascript\n  // but must be interpreted by an XML or HTML parser, and it must absolutely avoid breaking the syntax\n  // of an element attribute.\n  var quoteattr = function(s, preserveCR) {\n    preserveCR = preserveCR ? '&#13;' : '\\n';\n    return ('' + s) // Forces the conversion to string.\n      .replace(/&/g, '&amp;') // This MUST be the 1st replacement.\n      .replace(/'/g, '&apos;') // The 4 other predefined entities, required.\n      .replace(/\"/g, '&quot;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n       // Add other replacements here for HTML only \n       // Or for XML, only if the named entities are defined in its DTD.\n      .replace(/\\r\\n/g, preserveCR) // Must be before the next replacement.\n      .replace(/[\\r\\n]/g, preserveCR);\n  };\n\n  var getAuthorizeFormHelper = function(err, buffer) {\n    if (err) {\n      return callback(err);\n    }\n\n    var operation = 'authorize';\n    var additionalParameters = self.getAdditionalParams(req, operation);\n    var samlMessage = {\n      SAMLRequest: buffer.toString('base64')\n    };\n\n    Object.keys(additionalParameters).forEach(function(k) {\n      samlMessage[k] = additionalParameters[k] || '';\n    });\n\n    var formInputs = Object.keys(samlMessage).map(function(k) {\n      return '<input type=\"hidden\" name=\"' + k + '\" value=\"' + quoteattr(samlMessage[k]) + '\" />';\n    }).join('\\r\\n');\n\n    callback(null, [\n      '<!DOCTYPE html>',\n      '<html>',\n      '<head>',\n      '<meta charset=\"utf-8\">',\n      '<meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\">',\n      '</head>',\n      '<body onload=\"document.forms[0].submit()\">',\n      '<noscript>',\n      '<p><strong>Note:</strong> Since your browser does not support JavaScript, you must press the button below once to proceed.</p>',\n      '</noscript>',\n      '<form method=\"post\" action=\"' + encodeURI(self.options.entryPoint) + '\">',\n      formInputs,\n      '<input type=\"submit\" value=\"Submit\" />',\n      '</form>',\n      '<script>document.forms[0].style.display=\"none\";</script>', // Hide the form if JavaScript is enabled\n      '</body>',\n      '</html>'\n    ].join('\\r\\n'));\n  };\n\n  self.generateAuthorizeRequest(req, self.options.passive, function(err, request) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (self.options.skipRequestCompression) {\n      getAuthorizeFormHelper(null, new Buffer(request, 'utf8'));\n    } else {\n      zlib.deflateRaw(request, getAuthorizeFormHelper);\n    }\n  });\n\n};\n\nSAML.prototype.getLogoutUrl = function(req, callback) {\n  var request = this.generateLogoutRequest(req);\n  var operation = 'logout';\n  this.requestToUrl(request, null, operation, this.getAdditionalParams(req, operation), callback);\n};\n\nSAML.prototype.getLogoutResponseUrl = function(req, callback) {\n  var response = this.generateLogoutResponse(req, req.samlLogoutRequest);\n  var operation = 'logout';\n  this.requestToUrl(null, response, operation, this.getAdditionalParams(req, operation), callback);\n};\n\nSAML.prototype.certToPEM = function (cert) {\n  cert = cert.match(/.{1,64}/g).join('\\n');\n\n  if (cert.indexOf('-BEGIN CERTIFICATE-') === -1)\n    cert = \"-----BEGIN CERTIFICATE-----\\n\" + cert;\n  if (cert.indexOf('-END CERTIFICATE-') === -1)\n    cert = cert + \"\\n-----END CERTIFICATE-----\\n\";\n\n  return cert;\n};\n\n// This function checks that the |currentNode| in the |fullXml| document contains exactly 1 valid\n//   signature of the |currentNode|.\n//\n// See https://github.com/bergie/passport-saml/issues/19 for references to some of the attack\n//   vectors against SAML signature verification.\nSAML.prototype.validateSignature = function (fullXml, currentNode, cert) {\n  var self = this;\n  var xpathSigQuery = \".//*[local-name(.)='Signature' and \" +\n                      \"namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']\";\n  var signatures = xpath(currentNode, xpathSigQuery);\n  // This function is expecting to validate exactly one signature, so if we find more or fewer\n  //   than that, reject.\n  if (signatures.length != 1)\n    return false;\n  var signature = signatures[0];\n  var sig = new xmlCrypto.SignedXml();\n  sig.keyInfoProvider = {\n    getKeyInfo: function (key) {\n      return \"<X509Data></X509Data>\";\n    },\n    getKey: function (keyInfo) {\n      return self.certToPEM(cert);\n    }\n  };\n  sig.loadSignature(signature);\n  // We expect each signature to contain exactly one reference to the top level of the xml we\n  //   are validating, so if we see anything else, reject.\n  if (sig.references.length != 1 )\n    return false;\n  var refUri = sig.references[0].uri;\n  var refId = (refUri[0] === '#') ? refUri.substring(1) : refUri;\n  // If we can't find the reference at the top level, reject\n  var idAttribute = currentNode.getAttribute('ID') ? 'ID' : 'Id';\n  if (currentNode.getAttribute(idAttribute) != refId)\n    return false;\n  // If we find any extra referenced nodes, reject.  (xml-crypto only verifies one digest, so\n  //   multiple candidate references is bad news)\n  var totalReferencedNodes = xpath(currentNode.ownerDocument,\n                                  \"//*[@\" + idAttribute + \"='\" + refId + \"']\");\n  if (totalReferencedNodes.length > 1)\n    return false;\n  return sig.checkSignature(fullXml);\n};\n\nSAML.prototype.validatePostResponse = function (container, callback) {\n  var self = this;\n  var xml = new Buffer(container.SAMLResponse, 'base64').toString('utf8');\n  var doc = new xmldom.DOMParser().parseFromString(xml);\n\n  var inResponseTo = xpath(doc, \"/*[local-name()='Response']/@InResponseTo\");\n  if(inResponseTo){\n    inResponseTo = inResponseTo.length ? inResponseTo[0].nodeValue : null;\n  }\n\n  Q.fcall(function(){\n    if(self.options.validateInResponseTo){\n      if (inResponseTo) {\n        return Q.ninvoke(self.cacheProvider, 'get', inResponseTo)\n          .then(function(result) {\n            if (!result)\n              throw new Error('InResponseTo is not valid');\n            return Q();\n          });\n      }\n    } else {\n      return Q();\n    }\n  })\n  .then(function() {\n    // Check if this document has a valid top-level signature\n    var validSignature = false;\n    if (self.options.cert && self.validateSignature(xml, doc.documentElement, self.options.cert)) {\n      validSignature = true;\n    }\n\n    var assertions = xpath(doc, \"/*[local-name()='Response']/*[local-name()='Assertion']\");\n    var encryptedAssertions = xpath(doc,\n      \"/*[local-name()='Response']/*[local-name()='EncryptedAssertion']\");\n\n    if (assertions.length + encryptedAssertions.length > 1) {\n      // There's no reason I know of that we want to handle multiple assertions, and it seems like a\n      //   potential risk vector for signature scope issues, so treat this as an invalid signature\n      throw new Error('Invalid signature');\n    }\n\n    if (assertions.length == 1) {\n      if (self.options.cert &&\n          !validSignature &&\n          !self.validateSignature(xml, assertions[0], self.options.cert)) {\n        throw new Error('Invalid signature');\n      }\n      return self.processValidlySignedAssertion(assertions[0].toString(), inResponseTo, callback);\n    }\n\n    if (encryptedAssertions.length == 1) {\n      if (!self.options.decryptionPvk)\n        throw new Error('No decryption key for encrypted SAML response');\n\n      var encryptedDatas = xpath( encryptedAssertions[0], \"./*[local-name()='EncryptedData']\");\n      if (encryptedDatas.length != 1)\n        throw new Error('Invalid signature');\n      var encryptedDataXml = encryptedDatas[0].toString();\n\n      var xmlencOptions = { key: self.options.decryptionPvk };\n      return Q.ninvoke(xmlenc, 'decrypt', encryptedDataXml, xmlencOptions)\n        .then(function(decryptedXml) {\n          var decryptedDoc = new xmldom.DOMParser().parseFromString(decryptedXml);\n          var decryptedAssertions = xpath(decryptedDoc, \"/*[local-name()='Assertion']\");\n          if (decryptedAssertions.length != 1)\n            throw new Error('Invalid EncryptedAssertion content');\n\n          if (self.options.cert && \n              !validSignature && \n              !self.validateSignature(decryptedXml, decryptedAssertions[0], self.options.cert))\n            throw new Error('Invalid signature');\n\n          self.processValidlySignedAssertion(decryptedAssertions[0].toString(), inResponseTo, callback);\n        });\n    }\n\n    // If there's no assertion, fall back on xml2js response parsing for the status & \n    //   LogoutResponse code.\n\n    var parserConfig = {\n      explicitRoot: true,\n      explicitCharkey: true,\n      tagNameProcessors: [xml2js.processors.stripPrefix]\n    };\n    var parser = new xml2js.Parser(parserConfig);\n    return Q.ninvoke( parser, 'parseString', xml)\n      .then(function(doc) {\n        var response = doc.Response;\n        if (response) {\n          var assertion = response.Assertion;\n          if (!assertion) {\n            var status = response.Status;\n            if (status) {\n              var statusCode = status[0].StatusCode;\n              if (statusCode && statusCode[0].$.Value === \"urn:oasis:names:tc:SAML:2.0:status:Responder\") {\n                var nestedStatusCode = statusCode[0].StatusCode;\n                if (nestedStatusCode && nestedStatusCode[0].$.Value === \"urn:oasis:names:tc:SAML:2.0:status:NoPassive\") {\n                  if (self.options.cert && !validSignature) {\n                    throw new Error('Invalid signature');\n                  }\n                  return callback(null, null, false);\n                }\n              }\n\n              // Note that we're not requiring a valid signature before this logic -- since we are\n              //   throwing an error in any case, and some providers don't sign error results,\n              //   let's go ahead and give the potentially more helpful error.\n              if (statusCode && statusCode[0].$.Value) {\n                var msgType = statusCode[0].$.Value.match(/[^:]*$/)[0];\n                if (msgType != 'Success') {\n                  var msg = 'unspecified';\n                  if (status[0].StatusMessage) {\n                    msg = status[0].StatusMessage[0]._;\n                  } else if (statusCode[0].StatusCode) {\n                    msg = statusCode[0].StatusCode[0].$.Value.match(/[^:]*$/)[0];\n                  }\n                  var error = new Error('SAML provider returned ' + msgType + ' error: ' + msg);\n                  var builderOpts = {\n                    rootName: 'Status',\n                    headless: true\n                  };\n                  error.statusXml = new xml2js.Builder(builderOpts).buildObject(status[0]);\n                  throw error;\n                }\n              }\n            }\n            throw new Error('Missing SAML assertion');\n          }\n        } else {\n          if (self.options.cert && !validSignature) {\n            throw new Error('Invalid signature');\n          }\n          var logoutResponse = doc.LogoutResponse;\n          if (logoutResponse){\n            return callback(null, null, true);\n          } else {\n            throw new Error('Unknown SAML response message');\n          }\n        }\n      });\n  })\n  .fail(function(err) {\n    callback(err);\n  })\n  .done();\n};\n\nSAML.prototype.processValidlySignedAssertion = function(xml, inResponseTo, callback) {\n  var self = this;\n  var msg;\n  var parserConfig = {\n    explicitRoot: true,\n    tagNameProcessors: [xml2js.processors.stripPrefix]\n  };\n  var nowMs = new Date().getTime();\n  var profile = {};\n  var assertion;\n  var parser = new xml2js.Parser(parserConfig);\n  Q.ninvoke(parser, 'parseString', xml)\n  .then(function(doc) {\n    assertion = doc.Assertion;\n\n    var issuer = assertion.Issuer;\n    if (issuer) {\n      profile.issuer = issuer[0];\n    }\n\n    var authnStatement = assertion.AuthnStatement;\n    if (authnStatement) {\n      if (authnStatement[0].$ && authnStatement[0].$.SessionIndex) {\n        profile.sessionIndex = authnStatement[0].$.SessionIndex;\n      }\n    }\n\n    var subject = assertion.Subject;\n    var subjectConfirmation, confirmData;\n    if (subject) {\n      var nameID = subject[0].NameID;\n      if (nameID) {\n        profile.nameID = nameID[0]._ || nameID[0];\n\n        if (nameID[0].$ && nameID[0].$.Format) {\n          profile.nameIDFormat = nameID[0].$.Format;\n          profile.nameQualifier = nameID[0].$.NameQualifier;\n          profile.spNameQualifier = nameID[0].$.SPNameQualifier;\n        }\n      }\n\n      subjectConfirmation = subject[0].SubjectConfirmation ?\n                            subject[0].SubjectConfirmation[0] : null;\n      confirmData = subjectConfirmation && subjectConfirmation.SubjectConfirmationData ?\n                    subjectConfirmation.SubjectConfirmationData[0] : null;\n      if (subject[0].SubjectConfirmation && subject[0].SubjectConfirmation.length > 1) {\n        msg = 'Unable to process multiple SubjectConfirmations in SAML assertion';\n        throw new Error(msg);\n      }\n\n      if (subjectConfirmation) {\n        if (confirmData && confirmData.$) {\n          var subjectNotBefore = confirmData.$.NotBefore;\n          var subjectNotOnOrAfter = confirmData.$.NotOnOrAfter;\n\n          var subjErr = self.checkTimestampsValidityError(\n                          nowMs, subjectNotBefore, subjectNotOnOrAfter);\n          if (subjErr) {\n            throw subjErr;\n          }\n        }\n      }\n    }\n    \n    // Test to see that if we have a SubjectConfirmation InResponseTo that it matches\n    // the 'InResponseTo' attribute set in the Response\n    if (self.options.validateInResponseTo) {\n      if (subjectConfirmation) {\n        if (confirmData && confirmData.$) {\n          var subjectInResponseTo = confirmData.$.InResponseTo;\n          if (inResponseTo && subjectInResponseTo && subjectInResponseTo != inResponseTo) {\n            return Q.ninvoke(self.cacheProvider, 'remove', inResponseTo)\n              .then(function(){\n                throw new Error('InResponseTo is not valid');\n              });\n          } else if (subjectInResponseTo) {\n            var foundValidInResponseTo = false;\n            return Q.ninvoke(self.cacheProvider, 'get', subjectInResponseTo)\n              .then(function(result){\n                if (result) {\n                  var createdAt = new Date(result);\n                  if (nowMs < createdAt.getTime() + self.options.requestIdExpirationPeriodMs)\n                    foundValidInResponseTo = true;\n                }\n                return Q.ninvoke(self.cacheProvider, 'remove', inResponseTo );\n              })\n              .then(function(){\n                if (!foundValidInResponseTo) {\n                  throw new Error('InResponseTo is not valid');\n                }\n                return Q();\n              });\n          }\n        }\n      } else {\n        return Q.ninvoke(self.cacheProvider, 'remove', inResponseTo);\n      }\n    } else {\n      return Q();\n    }\n  })\n  .then(function(){\n    var conditions = assertion.Conditions ? assertion.Conditions[0] : null;\n    if (assertion.Conditions && assertion.Conditions.length > 1) {\n      msg = 'Unable to process multiple conditions in SAML assertion';\n      throw new Error(msg);\n    }\n    if(conditions && conditions.$) {\n      var conErr = self.checkTimestampsValidityError(\n                    nowMs, conditions.$.NotBefore, conditions.$.NotOnOrAfter);\n      if(conErr)\n        throw conErr;\n    }\n\n    var attributeStatement = assertion.AttributeStatement;\n    if (attributeStatement) {\n      var attributes = [].concat.apply([], attributeStatement.filter(function (attr) {\n        return Array.isArray(attr.Attribute);\n      }).map(function (attr) {\n        return attr.Attribute;\n      }));\n\n      var attrValueMapper = function(value) {\n        return typeof value === 'string' ? value : value._;\n      };\n\n      if (attributes) {\n        attributes.forEach(function (attribute) {\n         if(!attribute.hasOwnProperty('AttributeValue')) {\n            // if attributes has no AttributeValue child, continue\n            return;\n          }\n          var value = attribute.AttributeValue;\n          if (value.length === 1) {\n            profile[attribute.$.Name] = attrValueMapper(value[0]);\n          } else {\n            profile[attribute.$.Name] = value.map(attrValueMapper);\n          }\n        });\n      }\n    }\n\n    if (!profile.mail && profile['urn:oid:0.9.2342.19200300.100.1.3']) {\n      // See http://www.incommonfederation.org/attributesummary.html for definition of attribute OIDs\n      profile.mail = profile['urn:oid:0.9.2342.19200300.100.1.3'];\n    }\n\n    if (!profile.email && profile.mail) {\n      profile.email = profile.mail;\n    }\n\n    profile.getAssertionXml = function() { return xml; };\n\n    callback(null, profile, false);\n  })\n  .fail(function(err) {\n    callback(err);\n  })\n  .done();\n};\n\nSAML.prototype.checkTimestampsValidityError = function(nowMs, notBefore, notOnOrAfter) {\n  var self = this;\n  if (self.options.acceptedClockSkewMs == -1)\n      return null;\n\n  if (notBefore) {\n    var notBeforeMs = Date.parse(notBefore);\n    if (nowMs + self.options.acceptedClockSkewMs < notBeforeMs)\n        return new Error('SAML assertion not yet valid');\n  }\n  if (notOnOrAfter) {\n    var notOnOrAfterMs = Date.parse(notOnOrAfter);\n    if (nowMs - self.options.acceptedClockSkewMs >= notOnOrAfterMs)\n      return new Error('SAML assertion expired');\n  }\n\n  return null;\n};\n\nSAML.prototype.validatePostRequest = function (container, callback) {\n  var self = this;\n  var xml = new Buffer(container.SAMLRequest, 'base64').toString('utf8');\n  var dom = new xmldom.DOMParser().parseFromString(xml);\n  var parserConfig = {\n    explicitRoot: true,\n    tagNameProcessors: [xml2js.processors.stripPrefix]\n  };\n  var parser = new xml2js.Parser(parserConfig);\n  parser.parseString(xml, function (err, doc) {\n    if (err) {\n      return callback(err);\n    }\n\n    // Check if this document has a valid top-level signature\n    if (self.options.cert && !self.validateSignature(xml, dom.documentElement, self.options.cert)) {\n      return callback(new Error('Invalid signature'));\n    }\n\n    processValidlySignedPostRequest(self, doc, callback);\n  });\n};\n\nfunction processValidlySignedPostRequest(self, doc, callback) {\n    var request = doc.LogoutRequest;\n    if (request) {\n      var profile = {};\n      if (request.$.ID) {\n          profile.ID = request.$.ID;\n      } else {\n        return callback(new Error('Missing SAML LogoutRequest ID'));\n      }\n      var issuer = request.Issuer;\n      if (issuer) {\n        profile.issuer = issuer[0];\n      } else {\n        return callback(new Error('Missing SAML issuer'));\n      }\n\n      var nameID = request.NameID;\n      if (nameID) {\n        profile.nameID = nameID[0]._ || nameID[0];\n\n        if (nameID[0].$ && nameID[0].$.Format) {\n          profile.nameIDFormat = nameID[0].$.Format;\n        }\n      } else {\n        return callback(new Error('Missing SAML NameID'));\n      }\n      var sessionIndex = request.SessionIndex;\n      if (sessionIndex) {\n        profile.sessionIndex = sessionIndex[0];\n      }\n\n      callback(null, profile, true);\n    } else {\n      return callback(new Error('Unknown SAML request message'));\n    }\n}\n\nSAML.prototype.generateServiceProviderMetadata = function( decryptionCert ) {\n  var metadata = {\n    'EntityDescriptor' : {\n      '@xmlns': 'urn:oasis:names:tc:SAML:2.0:metadata',\n      '@xmlns:ds': 'http://www.w3.org/2000/09/xmldsig#',\n      '@entityID': this.options.issuer,\n      '@ID': this.options.issuer.replace(/\\W/g, '_'),\n      'SPSSODescriptor' : {\n        '@protocolSupportEnumeration': 'urn:oasis:names:tc:SAML:2.0:protocol',\n      },\n    }\n  };\n\n  if (this.options.decryptionPvk) {\n    if (!decryptionCert) {\n      throw new Error(\n        \"Missing decryptionCert while generating metadata for decrypting service provider\");\n    }\n\n    decryptionCert = decryptionCert.replace( /-+BEGIN CERTIFICATE-+\\r?\\n?/, '' );\n    decryptionCert = decryptionCert.replace( /-+END CERTIFICATE-+\\r?\\n?/, '' );\n    decryptionCert = decryptionCert.replace( /\\r\\n/g, '\\n' );\n\n    metadata.EntityDescriptor.SPSSODescriptor.KeyDescriptor = {\n      'ds:KeyInfo' : {\n        'ds:X509Data' : {\n          'ds:X509Certificate': {\n            '#text': decryptionCert\n          }\n        }\n      },\n      '#list' : [\n        // this should be the set that the xmlenc library supports\n        { 'EncryptionMethod': { '@Algorithm': 'http://www.w3.org/2001/04/xmlenc#aes256-cbc' } },\n        { 'EncryptionMethod': { '@Algorithm': 'http://www.w3.org/2001/04/xmlenc#aes128-cbc' } },\n        { 'EncryptionMethod': { '@Algorithm': 'http://www.w3.org/2001/04/xmlenc#tripledes-cbc' } },\n      ]\n    };\n  }\n\n  if (this.options.logoutCallbackUrl) {\n    metadata.EntityDescriptor.SPSSODescriptor.SingleLogoutService = {\n      '@Binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST',\n      '@Location': this.options.logoutCallbackUrl\n    };\n  }\n\n  metadata.EntityDescriptor.SPSSODescriptor.NameIDFormat = this.options.identifierFormat;\n  metadata.EntityDescriptor.SPSSODescriptor.AssertionConsumerService = {\n    '@index': '1',\n    '@isDefault': 'true',\n    '@Binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST',\n    '@Location': this.getCallbackUrl({})\n  };\n\n  return xmlbuilder.create(metadata).end({ pretty: true, indent: '  ', newline: '\\n' });\n};\n\nexports.SAML = SAML;\n","/home/travis/build/npmtest/node-npmtest-passport-saml/node_modules/passport-saml/lib/passport-saml/inmemory-cache-provider.js":"/**\n * Simple in memory cache provider.  To be used to store state of requests that needs\n * to be validated/checked when a response is received.\n *\n * This is the default implementation of a cache provider used by Passport-SAML.  For\n * multiple server instances/load balanced scenarios (I.e. the SAML request could have\n * been generated from a different server/process handling the SAML response) this\n * implementation will NOT be sufficient.\n *\n * The caller should provide their own implementation for a cache provider as defined\n * in the config options for Passport-SAML.\n * @param options\n * @constructor\n */\nvar CacheProvider = function (options) {\n    var self = this;\n    this.cacheKeys = {};\n\n    if (!options) {\n        options = {};\n    }\n\n    if(!options.keyExpirationPeriodMs){\n        options.keyExpirationPeriodMs = 28800000;  // 8 hours\n    }\n\n    this.options = options;\n\n    // Expire old cache keys\n    var expirationTimer = setInterval(function(){\n        var nowMs = new Date().getTime();\n        var keys = Object.keys(self.cacheKeys);\n        keys.forEach(function(key){\n            if(nowMs >= new Date(self.cacheKeys[key].createdAt).getTime() + self.options.keyExpirationPeriodMs){\n                self.remove(key, function(){});\n            }\n        });\n    }, this.options.keyExpirationPeriodMs);\n\n    // we only want this to run if the process is still open; it shouldn't hold the process open (issue #68)\n    //   (unref only introduced in node 0.9, so check whether we have it)\n    // Skip this in 0.10.34 due to https://github.com/joyent/node/issues/8900\n    if (expirationTimer.unref && process.version !== 'v0.10.34')\n        expirationTimer.unref();\n};\n\n\n/**\n * Store an item in the cache, using the specified key and value.\n * Internally will keep track of the time the item was added to the cache\n * @param id\n * @param value\n */\nCacheProvider.prototype.save = function(key, value, callback){\n    if(!this.cacheKeys[key])\n    {\n        this.cacheKeys[key] = {\n            createdAt: new Date().getTime(),\n            value: value\n        };\n\n        callback(null, this.cacheKeys[key]);\n    }\n    else\n    {\n        callback(null, null);\n    }\n\n};\n\n\n/**\n * Returns the value of the specified key in the cache\n * @param id\n * @returns {boolean}\n */\nCacheProvider.prototype.get = function(key, callback){\n    if(this.cacheKeys[key]){\n        callback(null, this.cacheKeys[key].value);\n    }\n    else\n    {\n        callback(null, null);\n    }\n\n};\n\n\n/**\n * Removes an item from the cache if it exists\n * @param key\n */\nCacheProvider.prototype.remove = function(key, callback){\n    if(this.cacheKeys[key])\n    {\n        delete this.cacheKeys[key];\n        callback(null, key);\n    }\n    else\n    {\n        callback(null, null);\n    }\n\n};\n\nexports.CacheProvider = CacheProvider;\n"}